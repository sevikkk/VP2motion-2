<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
	Xilinx Driver spi v2_00_a: xspi.h File Reference
</title>
<link href="../../../../../../../doc/usenglish/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>xspi.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi.html">XSpi</a></td></tr>

<tr><td colspan="2"><br><h2>Configuration options</h2></td></tr>
<tr><td colspan="2">The following options may be specified or retrieved for the device and enable/disable additional features of the SPI. Each of the options are bit fields, so more than one may be specified. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a1">XSP_MASTER_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2" doxytag="xspi.h::XSP_CLK_ACTIVE_LOW_OPTION"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>XSP_CLK_ACTIVE_LOW_OPTION</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="xspi.h::XSP_CLK_PHASE_1_OPTION"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>XSP_CLK_PHASE_1_OPTION</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="xspi.h::XSP_LOOPBACK_OPTION"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>XSP_LOOPBACK_OPTION</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="xspi.h::XSP_MANUAL_SSELECT_OPTION"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>XSP_MANUAL_SSELECT_OPTION</b></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a13">XSpi_mIntrDisable</a>(InstancePtr, DisableMask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a15">XSpi_mSetControlReg</a>(InstancePtr, Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a16">XSpi_mGetControlReg</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a17">XSpi_mGetStatusReg</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a18">XSpi_mSetSlaveSelectReg</a>(InstancePtr, Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a19">XSpi_mGetSlaveSelectReg</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a20">XSpi_mEnable</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a21">XSpi_mDisable</a>(InstancePtr)</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a22">XSpi_StatusHandler</a> )(void *CallBackRef, u32 StatusEvent, unsigned int ByteCount)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a23">XSpi_Initialize</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u16 DeviceId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a24">XSpi_LookupConfig</a> (u16 DeviceId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a25">XSpi_CfgInitialize</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, <a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *Config, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a26">XSpi_Start</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a27">XSpi_Stop</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a28">XSpi_Reset</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a29">XSpi_SetSlaveSelect</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u32 SlaveMask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a30">XSpi_GetSlaveSelect</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a31">XSpi_Transfer</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned int ByteCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a32">XSpi_SetStatusHandler</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, void *CallBackRef, <a class="el" href="xspi_8h.html#a22">XSpi_StatusHandler</a> FuncPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a33">XSpi_InterruptHandler</a> (void *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a34">XSpi_SelfTest</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a35">XSpi_GetStats</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, <a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a> *StatsPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a36">XSpi_ClearStats</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a37">XSpi_SetOptions</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a38">XSpi_GetOptions</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a1" doxytag="xspi.h::XSP_MASTER_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XSP_MASTER_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<pre>
 The Master option configures the SPI device as a master. By default, the
 device is a slave.</pre><p>
<pre> The Active Low Clock option configures the device's clock polarity. Setting
 this option means the clock is active low and the SCK signal idles high. By
 default, the clock is active high and SCK idles low.</pre><p>
<pre> The Clock Phase option configures the SPI device for one of two transfer
 formats.  A clock phase of 0, the default, means data if valid on the first
 SCK edge (rising or falling) after the slave select (SS) signal has been
 asserted. A clock phase of 1 means data is valid on the second SCK edge
 (rising or falling) after SS has been asserted.</pre><p>
<pre> The Loopback option configures the SPI device for loopback mode.  Data is
 looped back from the transmitter to the receiver.</pre><p>
<pre> The Manual Slave Select option, which is default, causes the device not
 to automatically drive the slave select.  The driver selects the device
 at the start of a transfer and deselects it at the end of a transfer.
 If this option is off, then the device automatically toggles the slave
 select signal between bytes in a transfer.
 </pre>     </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="xspi.h::XSpi_mDisable"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XSpi_mDisable          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disable the device. Preserves the current contents of the control register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a21">XSpi_mDisable(XSpi *InstancePtr)</a>; </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="xspi.h::XSpi_mEnable"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XSpi_mEnable          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable the device and uninhibit master transactions. Preserves the current contents of the control register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a20">XSpi_mEnable(XSpi *InstancePtr)</a>; </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="xspi.h::XSpi_mGetControlReg"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XSpi_mGetControlReg          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the contents of the control register. Use the XSP_CR_* constants defined above to interpret the bit-mask returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A 16-bit value representing the contents of the control register.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-Style signature: u16 <a class="el" href="xspi_8h.html#a16">XSpi_mGetControlReg(XSpi *InstancePtr)</a>; </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="xspi.h::XSpi_mGetSlaveSelectReg"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XSpi_mGetSlaveSelectReg          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the contents of the slave select register. Each bit in the mask corresponds to a slave select line. Only one slave should be selected at any one time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 32-bit value in the slave select register.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-Style signature: u32 <a class="el" href="xspi_8h.html#a19">XSpi_mGetSlaveSelectReg(XSpi *InstancePtr)</a>; </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="xspi.h::XSpi_mGetStatusReg"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XSpi_mGetStatusReg          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the contents of the status register. Use the XSP_SR_* constants defined above to interpret the bit-mask returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An 8-bit value representing the contents of the status register.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-Style signature: u8 <a class="el" href="xspi_8h.html#a17">XSpi_mGetStatusReg(XSpi *InstancePtr)</a>; </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="xspi.h::XSpi_mIntrDisable"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XSpi_mIntrDisable          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>DisableMask&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disable the specified Interrupts in the Interrupt Enable Register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DisableMask</em>&nbsp;</td><td>is the bitmask of the interrupts to be disabled. Bit positions of 1 will be disabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSP_INTR_* bits defined in <a class="el" href="xspi__l_8h.html">xspi_l.h</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-Style signature: void XSpi_IntrDisable(XSpi *InstancePtr, u32 DisableMask); </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="xspi.h::XSpi_mSetControlReg"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XSpi_mSetControlReg          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Mask&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the contents of the control register. Use the XSP_CR_* constants defined above to create the bit-mask to be written to the register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the 16-bit value to write to the control register.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a15">XSpi_mSetControlReg(XSpi *InstancePtr, u16 Mask)</a>; </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="xspi.h::XSpi_mSetSlaveSelectReg"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XSpi_mSetSlaveSelectReg          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Mask&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the contents of the slave select register. Each bit in the mask corresponds to a slave select line. Only one slave should be selected at any one time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the 32-bit value to write to the slave select register.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a18">XSpi_mSetSlaveSelectReg(XSpi *InstancePtr, u32 Mask)</a>; </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a22" doxytag="xspi.h::XSpi_StatusHandler"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="xspi_8h.html#a22">XSpi_StatusHandler</a>)(void *CallBackRef, u32 StatusEvent, unsigned int ByteCount)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The handler data type allows the user to define a callback function to handle the asynchronous processing of the SPI driver. The application using this driver is expected to define a handler of this type to support interrupt driven mode. The handler executes in an interrupt context such that minimal processing should be performed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>A callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is unimportant to the driver component, so it is a void pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatusEvent</em>&nbsp;</td><td>Indicates one or more status events that occurred. See the <a class="el" href="xspi_8c.html#a9">XSpi_SetStatusHandler()</a> for details on the status events that can be passed in the callback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>Indicates how many bytes of data were successfully transferred. This may be less than the number of bytes requested if the status event indicates an error. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a25" doxytag="xspi.h::XSpi_CfgInitialize"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_CfgInitialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>Config</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>EffectiveAddr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes a specific <a class="el" href="struct_x_spi.html">XSpi</a> instance such that the driver is ready to use.<p>
The state of the device after initialization is:<ul>
<li>Device is disabled</li><li>Slave mode</li><li>Active high clock polarity</li><li>Clock phase 0</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Config</em>&nbsp;</td><td>is a reference to a structure containing information about a specific SPI device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_DEVICE_IS_STARTED if the device is started. It must be stopped to re-initialize.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="xspi.h::XSpi_ClearStats"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XSpi_ClearStats           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Clears the statistics for the SPI device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Statistics are not updated in polled mode of operation. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="xspi.h::XSpi_GetOptions"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XSpi_GetOptions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function gets the options for the SPI device. The options control how the device behaves relative to the SPI bus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
Options contains the specified options to be set. This is a bit mask where a 1 means to turn the option on, and a 0 means to turn the option off. One or more bit values may be contained in the mask. See the bit definitions named XSP_*_OPTIONS in the file <a class="el" href="xspi_8h.html">xspi.h</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="xspi.h::XSpi_GetSlaveSelect"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XSpi_GetSlaveSelect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the current slave select bit mask for the SPI device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value returned is a 32-bit mask with a 1 in the bit position of the slave currently selected. The value may be zero if no slaves are selected.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="xspi.h::XSpi_GetStats"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XSpi_GetStats           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>StatsPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets a copy of the statistics for an SPI device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatsPtr</em>&nbsp;</td><td>is a pointer to a <a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a> structure which will get a copy of current statistics.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Statistics are not updated in polled mode of operation. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="xspi.h::XSpi_Initialize"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_Initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap> <em>DeviceId</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes a specific <a class="el" href="struct_x_spi.html">XSpi</a> instance such that the driver is ready to use.<p>
The state of the device after initialization is:<ul>
<li>Device is disabled</li><li>Slave mode</li><li>Active high clock polarity</li><li>Clock phase 0</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_spi.html">XSpi</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_spi.html">XSpi</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if successful.</li><li>XST_DEVICE_IS_STARTED if the device is started. It must be stopped to re-initialize.</li><li>XST_DEVICE_NOT_FOUND if the device was not found in the configuration such that initialization could not be accomplished.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="xspi.h::XSpi_InterruptHandler"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XSpi_InterruptHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The interrupt handler for SPI interrupts. This function must be connected by the user to an interrupt source. This function does not save and restore the processor context such that the user must provide this processing.<p>
The interrupts that are handled are:<p>
<ul>
<li>Mode Fault Error. This interrupt is generated if this device is selected as a slave when it is configured as a master. The driver aborts any data transfer that is in progress by resetting FIFOs (if present) and resetting its buffer pointers. The upper layer software is informed of the error.</li></ul>
<p>
<ul>
<li>Data Transmit Register (FIFO) Empty. This interrupt is generated when the transmit register or FIFO is empty. The driver uses this interrupt during a transmission to continually send/receive data until there is no more data to send/receive.</li></ul>
<p>
<ul>
<li>Data Transmit Register (FIFO) Underrun. This interrupt is generated when the SPI device, when configured as a slave, attempts to read an empty DTR/FIFO. An empty DTR/FIFO usually means that software is not giving the device data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li></ul>
<p>
<ul>
<li>Data Receive Register (FIFO) Overrun. This interrupt is generated when the SPI device attempts to write a received byte to an already full DRR/FIFO. A full DRR/FIFO usually means software is not emptying the data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li></ul>
<p>
<ul>
<li>Slave Mode Fault Error. This interrupt is generated if a slave device is selected as a slave while it is disabled. No action is taken by the driver other than to inform the upper layer software of the error.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The slave select register is being set to deselect the slave when a transfer is complete. This is being done regardless of whether it is a slave or a master since the hardware does not drive the slave select as a slave.     </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="xspi.h::XSpi_LookupConfig"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a>* XSpi_LookupConfig           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u16&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>DeviceId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Looks up the device configuration based on the unique device ID. A table contains the configuration info for each device in the system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>contains the ID of the device to look up the configuration for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
A pointer to the configuration found or NULL if the specified device ID was not found. See <a class="el" href="xspi_8h.html">xspi.h</a> for the definition of <a class="el" href="struct_x_spi___config.html">XSpi_Config</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="xspi.h::XSpi_Reset"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XSpi_Reset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resets the SPI device by writing to the Software Reset register. Reset must only be called after the driver has been initialized. The configuration of the device after reset is the same as its configuration after initialization. Refer to the XSpi_Initialize function for more details. This is a hard reset of the device. Any data transfer that is in progress is aborted.<p>
The upper layer software is responsible for re-configuring (if necessary) and restarting the SPI device after the reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="xspi.h::XSpi_SelfTest"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_SelfTest           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Runs a self-test on the driver/device. The self-test is destructive in that a reset of the device is performed in order to check the reset values of the registers and to get the device into a known state. A simple loopback test is also performed to verify that transmit and receive are working properly. The device is changed to master mode for the loopback test, since only a master can initiate a data transfer.<p>
Upon successful return from the self-test, the device is reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful</li><li>XST_REGISTER_ERROR indicates a register did not read or write correctly</li><li>XST_LOOPBACK_ERROR if a loopback error occurred.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="xspi.h::XSpi_SetOptions"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_SetOptions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Options</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function sets the options for the SPI device driver. The options control how the device behaves relative to the SPI bus. The device must be idle rather than busy transferring data before setting these device options.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>contains the specified options to be set. This is a bit mask where a 1 means to turn the option on, and a 0 means to turn the option off. One or more bit values may be contained in the mask. See the bit definitions named XSP_*_OPTIONS in the file <a class="el" href="xspi_8h.html">xspi.h</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>-XST_SUCCESS if options are successfully set.<ul>
<li>XST_DEVICE_BUSY if the device is currently transferring data. The transfer must complete or be aborted before setting options.</li><li>XST_SPI_SLAVE_ONLY if the caller attempted to configure a slave-only device as a master.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function makes use of internal resources that are shared between the <a class="el" href="xspi_8c.html#a4">XSpi_Stop()</a> and <a class="el" href="xspi_8h.html#a37">XSpi_SetOptions()</a> functions. So if one task might be setting device options while another is trying to stop the device, the user is required to provide protection of this shared data (typically using a semaphore).     </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="xspi.h::XSpi_SetSlaveSelect"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_SetSlaveSelect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>SlaveMask</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Selects or deselect the slave with which the master communicates. Each slave that can be selected is represented in the slave select register by a bit. The argument passed to this function is the bit mask with a 1 in the bit position of the slave being selected. Only one slave can be selected.<p>
The user is not allowed to deselect the slave while a transfer is in progress. If no transfer is in progress, the user can select a new slave, which implicitly deselects the current slave. In order to explicitly deselect the current slave, a zero can be passed in as the argument to the function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveMask</em>&nbsp;</td><td>is a 32-bit mask with a 1 in the bit position of the slave being selected. Only one slave can be selected. The SlaveMask can be zero if the slave is being deselected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the slave is selected or deselected successfully.</li><li>XST_DEVICE_BUSY if a transfer is in progress, slave cannot be changed</li><li>XST_SPI_TOO_MANY_SLAVES if more than one slave is being selected.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function only sets the slave which will be selected when a transfer occurs. The slave is not selected when the SPI is idle. The slave select has no affect when the device is configured as a slave.     </td>
  </tr>
</table>
<a class="anchor" name="a32" doxytag="xspi.h::XSpi_SetStatusHandler"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XSpi_SetStatusHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="xspi_8h.html#a22">XSpi_StatusHandler</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>FuncPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the status callback function, the status handler, which the driver calls when it encounters conditions that should be reported to the higher layer software. The handler executes in an interrupt context, so it must minimize the amount of processing performed such as transferring data to a thread context. One of the following status events is passed to the status handler. <pre><ul>
<li>XST_SPI_MODE_FAULT	A mode fault error occurred, meaning another
				master tried to select this device as a slave
				when this device was configured to be a master.
				Any transfer in progress is aborted.</li></ul>
</pre><p>
<pre><ul>
<li>XST_SPI_TRANSFER_DONE	The requested data transfer is done</li></ul>
</pre><p>
<pre><ul>
<li>XST_SPI_TRANSMIT_UNDERRUN	As a slave device, the master clocked
				data but there were none available in the
				transmit register/FIFO. This typically means the
				slave application did not issue a transfer
				request fast enough, or the processor/driver
				could not fill the transmit register/FIFO fast
				enough.</li></ul>
</pre><p>
<pre><ul>
<li>XST_SPI_RECEIVE_OVERRUN	The SPI device lost data. Data was received
				but the receive data register/FIFO was full.
				This indicates that the device is receiving data
				faster than the processor/driver can consume it.</li></ul>
</pre><p>
<pre><ul>
<li>XST_SPI_SLAVE_MODE_FAULT	A slave SPI device was selected as a slave while
				it was disabled.  This indicates the master is
				already transferring data (which is being
				dropped until the slave application issues a
				transfer).
 
 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.
 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back
 when the callback function is invoked.
 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The handler is called within interrupt context, so it should do its work
 quickly and queue potentially time-consuming work to a task-level thread.
</li></ul>
</pre>    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="xspi.h::XSpi_Start"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_Start           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function enables interrupts for the SPI device. If the Spi driver is used in interrupt mode, it is up to the user to connect the SPI interrupt handler to the interrupt controller before this function is called. If the Spi driver is used in polled mode the user has to disable the Global Interrupts after this function is called. If the device is configured with FIFOs, the FIFOs are reset at this time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the device is successfully started</li><li>XST_DEVICE_IS_STARTED if the device was already started.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="xspi.h::XSpi_Stop"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_Stop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function stops the SPI device by disabling interrupts and disabling the device itself. Interrupts are disabled only within the device itself. If desired, the caller is responsible for disabling interrupts in the interrupt controller and disconnecting the interrupt handler from the interrupt controller.<p>
In interrupt mode, if the device is in progress of transferring data on the SPI bus, this function returns a status indicating the device is busy. The user will be notified via the status handler when the transfer is complete, and at that time can again try to stop the device. As a master, we do not allow the device to be stopped while a transfer is in progress because the slave may be left in a bad state. As a slave, we do not allow the device to be stopped while a transfer is in progress because the master is not done with its transfer yet.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>-XST_SUCCESS if the device is successfully started. -XST_DEVICE_BUSY if a transfer is in progress and cannot be stopped.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function makes use of internal resources that are shared between the <a class="el" href="xspi_8c.html#a4">XSpi_Stop()</a> and <a class="el" href="xspi_8h.html#a37">XSpi_SetOptions()</a> functions. So if one task might be setting device options while another is trying to stop the device, the user is is required to provide protection of this shared data (typically using a semaphore).     </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="xspi.h::XSpi_Transfer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XSpi_Transfer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>SendBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>ByteCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transfers the specified data on the SPI bus. If the SPI device is configured to be a master, this function initiates bus communication and sends/receives the data to/from the selected SPI slave. If the SPI device is configured to be a slave, this function prepares the data to be sent/received when selected by a master. For every byte sent, a byte is received.<p>
This function/driver operates in interrupt mode and polled mode.<ul>
<li>In interrupt mode this function is non-blocking and the transfer is initiated by this function and completed by the interrupt service routine.</li><li>In polled mode this function is blocking and the control exits this function only after all the requested data is transferred.</li></ul>
<p>
The caller has the option of providing two different buffers for send and receive, or one buffer for both send and receive, or no buffer for receive. The receive buffer must be at least as big as the send buffer to prevent unwanted memory writes. This implies that the byte count passed in as an argument must be the smaller of the two buffers if they differ in size. Here are some sample usages: <pre>
	XSpi_Transfer(InstancePtr, SendBuf, RecvBuf, ByteCount)
	The caller wishes to send and receive, and provides two different
	buffers for send and receive.</pre><p>
<pre>	XSpi_Transfer(InstancePtr, SendBuf, NULL, ByteCount)
	The caller wishes only to send and does not care about the received
	data. The driver ignores the received data in this case.</pre><p>
<pre>	XSpi_Transfer(InstancePtr, SendBuf, SendBuf, ByteCount)
	The caller wishes to send and receive, but provides the same buffer
	for doing both. The driver sends the data and overwrites the send
	buffer with received data as it transfers the data.</pre><p>
<pre>	XSpi_Transfer(InstancePtr, RecvBuf, RecvBuf, ByteCount)
	The caller wishes to only receive and does not care about sending
	data.  In this case, the caller must still provide a send buffer, but
	it can be the same as the receive buffer if the caller does not care
	what it sends. The device must send N bytes of data if it wishes to
	receive N bytes of data.
 </pre> In interrupt mode, though this function takes a buffer as an argument, the driver can only transfer a limited number of bytes at time. It transfers only one byte at a time if there are no FIFOs, or it can transfer the number of bytes up to the size of the FIFO if FIFOs exist.<ul>
<li>In interrupt mode a call to this function only starts the transfer, the subsequent transfer of the data is performed by the interrupt service routine until the entire buffer has been transferred.The status callback function is called when the entire buffer has been sent/received.</li><li>In polled mode this function is blocking and the control exits this function only after all the requested data is transferred.</li></ul>
<p>
As a master, the SetSlaveSelect function must be called prior to this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SendBufPtr</em>&nbsp;</td><td>is a pointer to a buffer of data which is to be sent. This buffer must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RecvBufPtr</em>&nbsp;</td><td>is a pointer to a buffer which will be filled with received data. This argument can be NULL if the caller does not wish to receive data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>contains the number of bytes to send/receive. The number of bytes received always equals the number of bytes sent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>-XST_SUCCESS if the buffers are successfully handed off to the driver for transfer. Otherwise, returns:<ul>
<li>XST_DEVICE_IS_STOPPED if the device must be started before transferring data.</li><li>XST_DEVICE_BUSY indicates that a data transfer is already in progress. This is determined by the driver.</li><li>XST_SPI_NO_SLAVE indicates the device is configured as a master and a slave has not yet been selected.</li></ul>
</dd></dl>
<p>
This function is not thread-safe. The higher layer software must ensure that no two threads are transferring data on the SPI bus at the same time.     </td>
  </tr>
</table>
<p class="Copyright">
Copyright &copy; 1995-2008 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>

