<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
	Xilinx Driver spi v2_00_a: spi v2_00_a
</title>
<link href="../../../../../../../doc/usenglish/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>spi v2_00_a </h1>
<p>
This component contains the implementation of the <a class="el" href="struct_x_spi.html">XSpi</a> component. It is the driver for an SPI master or slave device. It supports 8-bit, 16-bit and 32-bit wide data transfers.<p>
SPI is a 4-wire serial interface. It is a full-duplex, synchronous bus that facilitates communication between one master and one slave. The device is always full-duplex, which means that for every byte sent, one is received, and vice-versa. The master controls the clock, so it can regulate when it wants to send or receive data. The slave is under control of the master, it must respond quickly since it has no control of the clock and must send/receive data as fast or as slow as the master does.<p>
The application software between master and slave must implement a higher layer protocol so that slaves know what to transmit to the master and when.<p>
<b>Initialization &amp; Configuration</b><p>
The <a class="el" href="struct_x_spi___config.html">XSpi_Config</a> structure is used by the driver to configure itself. This configuration structure is typically created by the tool-chain based on HW build properties.<p>
To support multiple runtime loading and initialization strategies employed by various operating systems, the driver instance can be initialized in one of the following ways:<p>
<ul>
<li>XSpi_Initialize(InstancePtr, DeviceId) - The driver looks up its own configuration structure created by the tool-chain based on an ID provided by the tool-chain.</li></ul>
<p>
<ul>
<li>XSpi_CfgInitialize(InstancePtr, CfgPtr, EffectiveAddr) - Uses a configuration structure provided by the caller. If running in a system with address translation, the provided virtual memory base address replaces the physical address present in the configuration structure.</li></ul>
<p>
<b>Multiple Masters</b><p>
More than one master can exist, but arbitration is the responsibility of the higher layer software. The device driver does not perform any type of arbitration.<p>
<b>Multiple Slaves</b><p>
Multiple slaves are supported by adding additional slave select (SS) signals to each device, one for each slave on the bus. The driver ensures that only one slave can be selected at any one time.<p>
<b>FIFOs</b><p>
The SPI hardware is parameterized such that it can be built with or without FIFOs. When using FIFOs, both send and receive must have FIFOs. The driver will not function correctly if one direction has a FIFO but the other direction does not. The frequency of the interrupts which occur is proportional to the data rate such that high data rates without the FIFOs could cause the software to consume large amounts of processing time. The driver is designed to work with or without the FIFOs.<p>
<b>Interrupts</b><p>
The user must connect the interrupt handler of the driver, XSpi_InterruptHandler to an interrupt system such that it will be called when an interrupt occurs. This function does not save and restore the processor context such that the user must provide this processing.<p>
The driver handles the following interrupts:<ul>
<li>Data Transmit Register/FIFO Empty</li><li>Data Transmit Register/FIFO Underrun</li><li>Data Receive Register/FIFO Overrun</li><li>Mode Fault Error</li><li>Slave Mode Fault Error</li></ul>
<p>
The Data Transmit Register/FIFO Empty interrupt indicates that the SPI device has transmitted all the data available to transmit, and now its data register (or FIFO) is empty. The driver uses this interrupt to indicate progress while sending data. The driver may have more data to send, in which case the data transmit register (or FIFO) is filled for subsequent transmission. When this interrupt arrives and all the data has been sent, the driver invokes the status callback with a value of XST_SPI_TRANSFER_DONE to inform the upper layer software that all data has been sent.<p>
The Data Transmit Register/FIFO Underrun interrupt indicates that, as slave, the SPI device was required to transmit but there was no data available to transmit in the transmit register (or FIFO). This may not be an error if the master is not expecting data, but in the case where the master is expecting data this serves as a notification of such a condition. The driver reports this condition to the upper layer software through the status handler.<p>
The Data Receive Register/FIFO Overrun interrupt indicates that the SPI device received data and subsequently dropped the data because the data receive register (or FIFO) was full. The interrupt applies to both master and slave operation. The driver reports this condition to the upper layer software through the status handler. This likely indicates a problem with the higher layer protocol, or a problem with the slave performance.<p>
The Mode Fault Error interrupt indicates that while configured as a master, the device was selected as a slave by another master. This can be used by the application for arbitration in a multimaster environment or to indicate a problem with arbitration. When this interrupt occurs, the driver invokes the status callback with a status value of XST_SPI_MODE_FAULT. It is up to the application to resolve the conflict.<p>
The Slave Mode Fault Error interrupt indicates that a slave device was selected as a slave by a master, but the slave device was disabled. This can be used during system debugging or by the slave application to learn when the slave application has not prepared for a master operation in a timely fashion. This likely indicates a problem with the higher layer protocol, or a problem with the slave performance.<p>
<b>Polled Operation</b><p>
This driver operates in polled mode operation too. To put the driver in polled mode the Global Interrupt must be disabled after the Spi is Initialized and Spi driver is started.<p>
Statistics are not updated in this mode of operation.<p>
<b>Device Busy</b><p>
Some operations are disallowed when the device is busy. The driver tracks whether a device is busy. The device is considered busy when a data transfer request is outstanding, and is considered not busy only when that transfer completes (or is aborted with a mode fault error). This applies to both master and slave devices.<p>
<b>Device Configuration</b><p>
The device can be configured in various ways during the FPGA implementation process. Configuration parameters are stored in the <a class="el" href="xspi__g_8c.html">xspi_g.c</a> file or passed in via _CfgInitialize(). A table is defined where each entry contains configuration information for an SPI device. This information includes such things as the base address of the memory-mapped device, the number of slave select bits in the device, and whether the device has FIFOs and is configured as slave-only.<p>
<b>RTOS Independence</b><p>
This driver is intended to be RTOS and processor independent. It works with physical addresses only. Any needs for dynamic memory management, threads or thread mutual exclusion, virtual memory, or cache control must be satisfied by the layer above this driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 1.00a rpm  10/11/01 First release
 1.00b jhl  03/14/02 Repartitioned driver for smaller files.
 1.01a jvb  12/14/05 I separated dependency on the static config table and
                     xparameters.h from the driver initialization by moving
                     _Initialize and _LookupConfig to _sinit.c. I also added
                     the new _CfgInitialize routine.
 1.11a wgr  03/22/07 Converted to new coding style.
 1.11a  sv  02/22/08 Added the definition of LSB-MSB first option in <a class="el" href="xspi__l_8h.html">xspi_l.h</a>.
 1.12a sdm  03/22/08 Updated the code to support 16/32 bit transfer width and
                     polled mode of operation, removed the macros in <a class="el" href="xspi__l_8h.html">xspi_l.h</a>,
                     added macros in <a class="el" href="xspi_8h.html">xspi.h</a> file, moved the interrupt
                     register/bit definitions from <a class="el" href="xspi__i_8h.html">xspi_i.h</a> to xpsi_l.h.
                     Even for the polled mode of operation the Interrupt Logic
                     in the core should be included. The driver can be put in
                     polled mode of operation by disabling the Global Interrupt
                     after the Spi Initialization is completed and Spi is
                     started.
 2.00a sdm  07/30/08 Updated the code to support 16/32 bit transfer width and
                     polled mode of operation, removed the macros in <a class="el" href="xspi__l_8h.html">xspi_l.h</a>,
                     added macros in <a class="el" href="xspi_8h.html">xspi.h</a> file, moved the interrupt
                     register/bit definitions from <a class="el" href="xspi__i_8h.html">xspi_i.h</a> to xpsi_l.h.
                     Even for the polled mode of operation the Interrupt Logic
                     in the core should be included. The driver can be put in
                     polled mode of operation by disabling the Global Interrupt
                     after the Spi Initialization is completed and Spi is
                     started.
 </pre> <p class="Copyright">
Copyright &copy; 1995-2008 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>

